/**
 * Video Types
 * 
 * Type definitions for video transcript extraction and vectorization.
 * Supports YouTube, Vimeo, Loom, and other video platforms.
 * 
 * @packageDocumentation
 */

/**
 * Supported video platforms
 */
export type VideoPlatform = 
  | 'youtube'
  | 'vimeo'
  | 'loom'
  | 'dailymotion'
  | 'twitch'
  | 'unknown';

/**
 * Transcript segment with timing
 */
export interface ITranscriptSegment {
  /** Segment text */
  text: string;
  /** Start time in seconds */
  startTime: number;
  /** Duration in seconds */
  duration: number;
  /** End time in seconds */
  endTime: number;
}

/**
 * Video transcript
 */
export interface IVideoTranscript {
  /** Full transcript text */
  fullText: string;
  /** Transcript segments with timing */
  segments: ITranscriptSegment[];
  /** Language of the transcript */
  language: string;
  /** Whether this is auto-generated */
  isAutoGenerated: boolean;
}

/**
 * Video metadata
 */
export interface IVideoMetadata {
  /** Video ID on the platform */
  videoId: string;
  /** Platform the video is from */
  platform: VideoPlatform;
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Channel/author name */
  author: string;
  /** Channel/author URL */
  authorUrl?: string;
  /** Video duration in seconds */
  duration: number;
  /** Thumbnail URL */
  thumbnailUrl?: string;
  /** Original video URL */
  videoUrl: string;
  /** Publish date */
  publishedAt?: Date;
  /** View count if available */
  viewCount?: number;
  /** Tags/keywords */
  tags: string[];
}

/**
 * Processed video with transcript
 */
export interface IProcessedVideo {
  /** Unique ID */
  id: string;
  /** Video metadata */
  metadata: IVideoMetadata;
  /** Video transcript */
  transcript: IVideoTranscript | null;
  /** Whether vectorized */
  isVectorized: boolean;
  /** Vector entry IDs */
  vectorEntryIds: string[];
  /** Processing status */
  status: VideoProcessingStatus;
  /** Error message if failed */
  error?: string;
  /** Created timestamp */
  createdAt: Date;
  /** Updated timestamp */
  updatedAt: Date;
}

/**
 * Video processing status
 */
export type VideoProcessingStatus =
  | 'pending'
  | 'fetching_metadata'
  | 'fetching_transcript'
  | 'transcribing'
  | 'vectorizing'
  | 'complete'
  | 'error';

/**
 * Video processing progress
 */
export interface IVideoProcessingProgress {
  /** Video URL being processed */
  videoUrl: string;
  /** Current status */
  status: VideoProcessingStatus;
  /** Progress percentage (0-100) */
  progress: number;
  /** Status message */
  message: string;
}

/**
 * Video processing options
 */
export interface IVideoProcessingOptions {
  /** Whether to auto-vectorize after processing */
  autoVectorize: boolean;
  /** Preferred transcript language */
  preferredLanguage: string;
  /** Whether to use audio transcription as fallback */
  useAudioFallback: boolean;
  /** Chunk size for vectorization */
  chunkSize: number;
  /** Chunk overlap for vectorization */
  chunkOverlap: number;
}

/**
 * Default processing options
 */
export const DEFAULT_VIDEO_OPTIONS: IVideoProcessingOptions = {
  autoVectorize: true,
  preferredLanguage: 'en',
  useAudioFallback: true,
  chunkSize: 1000,
  chunkOverlap: 200,
};

/**
 * Video state
 */
export interface IVideoState {
  /** Processed videos */
  videos: IProcessedVideo[];
  /** Whether processing is in progress */
  isProcessing: boolean;
  /** Current processing progress */
  progress: IVideoProcessingProgress | null;
  /** Error message */
  error: string | null;
}

/**
 * Video context interface
 */
export interface IVideoContext extends IVideoState {
  /** Process a video URL */
  processVideo: (url: string, options?: Partial<IVideoProcessingOptions>) => Promise<IProcessedVideo>;
  /** Vectorize a video */
  vectorizeVideo: (videoId: string) => Promise<void>;
  /** Delete a video */
  deleteVideo: (videoId: string) => Promise<void>;
  /** Clear error */
  clearError: () => void;
}

/**
 * Platform URL patterns
 */
export const PLATFORM_PATTERNS: Record<VideoPlatform, RegExp[]> = {
  youtube: [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
  ],
  vimeo: [
    /vimeo\.com\/(\d+)/,
    /player\.vimeo\.com\/video\/(\d+)/,
  ],
  loom: [
    /loom\.com\/share\/([a-zA-Z0-9]+)/,
    /loom\.com\/embed\/([a-zA-Z0-9]+)/,
  ],
  dailymotion: [
    /dailymotion\.com\/video\/([a-zA-Z0-9]+)/,
    /dai\.ly\/([a-zA-Z0-9]+)/,
  ],
  twitch: [
    /twitch\.tv\/videos\/(\d+)/,
    /twitch\.tv\/([a-zA-Z0-9_]+)\/clip\/([a-zA-Z0-9_-]+)/,
  ],
  unknown: [],
};

/**
 * Parse video URL to extract platform and video ID
 * @param url - Video URL
 * @returns Platform and video ID, or null if not recognized
 */
export function parseVideoUrl(url: string): { platform: VideoPlatform; videoId: string } | null {
  for (const [platform, patterns] of Object.entries(PLATFORM_PATTERNS) as [VideoPlatform, RegExp[]][]) {
    if (platform === 'unknown') continue;
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return {
          platform,
          videoId: match[1],
        };
      }
    }
  }
  
  return null;
}

/**
 * Format duration in seconds to human-readable string
 * @param seconds - Duration in seconds
 * @returns Formatted duration (e.g., "1:23:45" or "12:34")
 */
export function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}
