/**
 * useVideos Hook
 * 
 * Manages video transcript extraction and vectorization.
 * Supports YouTube, Vimeo, Loom, and other platforms.
 * 
 * @packageDocumentation
 */

import { useState, useCallback } from 'react';
import {
  type IProcessedVideo,
  type IVideoProcessingProgress,
  type IVideoProcessingOptions,
  type IVideoMetadata,
  type IVideoTranscript,
  type VideoPlatform,
  DEFAULT_VIDEO_OPTIONS,
  parseVideoUrl,
} from '../types/video.types';

/**
 * Options for useVideos hook
 */
export interface UseVideosOptions {
  /** Default processing options */
  defaultOptions?: Partial<IVideoProcessingOptions>;
}

/**
 * Return type for useVideos hook
 */
export interface UseVideosReturn {
  /** Processed videos */
  videos: IProcessedVideo[];
  /** Whether processing is in progress */
  isProcessing: boolean;
  /** Current processing progress */
  progress: IVideoProcessingProgress | null;
  /** Error message */
  error: string | null;
  /** Process a video URL */
  processVideo: (url: string, options?: Partial<IVideoProcessingOptions>) => Promise<IProcessedVideo | null>;
  /** Vectorize a video */
  vectorizeVideo: (videoId: string) => Promise<void>;
  /** Delete a video */
  deleteVideo: (videoId: string) => Promise<void>;
  /** Clear error */
  clearError: () => void;
}

/**
 * Generate unique ID
 */
function generateId(): string {
  return `video_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Fetch YouTube video metadata using oEmbed
 */
async function fetchYouTubeMetadata(videoId: string): Promise<Partial<IVideoMetadata>> {
  const url = `https://www.youtube.com/watch?v=${videoId}`;
  const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
  
  try {
    const response = await fetch(oembedUrl);
    if (!response.ok) throw new Error('Failed to fetch metadata');
    
    const data = await response.json();
    return {
      title: data.title || 'Untitled Video',
      author: data.author_name || 'Unknown',
      authorUrl: data.author_url,
      thumbnailUrl: data.thumbnail_url,
    };
  } catch {
    return {
      title: 'YouTube Video',
      author: 'Unknown',
    };
  }
}

/**
 * Fetch Vimeo video metadata using oEmbed
 */
async function fetchVimeoMetadata(videoId: string): Promise<Partial<IVideoMetadata>> {
  const oembedUrl = `https://vimeo.com/api/oembed.json?url=https://vimeo.com/${videoId}`;
  
  try {
    const response = await fetch(oembedUrl);
    if (!response.ok) throw new Error('Failed to fetch metadata');
    
    const data = await response.json();
    return {
      title: data.title || 'Untitled Video',
      author: data.author_name || 'Unknown',
      authorUrl: data.author_url,
      thumbnailUrl: data.thumbnail_url,
      duration: data.duration || 0,
      description: data.description || '',
    };
  } catch {
    return {
      title: 'Vimeo Video',
      author: 'Unknown',
    };
  }
}

/**
 * Fetch generic video metadata
 */
async function fetchVideoMetadata(
  platform: VideoPlatform,
  videoId: string,
  videoUrl: string
): Promise<IVideoMetadata> {
  let partialMetadata: Partial<IVideoMetadata> = {};
  
  switch (platform) {
    case 'youtube':
      partialMetadata = await fetchYouTubeMetadata(videoId);
      break;
    case 'vimeo':
      partialMetadata = await fetchVimeoMetadata(videoId);
      break;
    case 'loom':
      partialMetadata = { title: 'Loom Video', author: 'Unknown' };
      break;
    default:
      partialMetadata = { title: 'Video', author: 'Unknown' };
  }
  
  return {
    videoId,
    platform,
    title: partialMetadata.title || 'Untitled Video',
    description: partialMetadata.description || '',
    author: partialMetadata.author || 'Unknown',
    authorUrl: partialMetadata.authorUrl,
    duration: partialMetadata.duration || 0,
    thumbnailUrl: partialMetadata.thumbnailUrl,
    videoUrl,
    tags: [],
  };
}

/**
 * Fetch YouTube transcript using a proxy or direct fetch
 * Note: In production, this would use youtube-transcript package or a backend service
 */
async function fetchYouTubeTranscript(videoId: string): Promise<IVideoTranscript | null> {
  try {
    const response = await fetch(
      `https://www.youtube.com/watch?v=${videoId}`,
      { mode: 'no-cors' }
    );
    
    if (!response.ok) {
      return null;
    }
    
    return {
      fullText: `[Transcript for video ${videoId} - In production, use youtube-transcript package or API]`,
      segments: [],
      language: 'en',
      isAutoGenerated: true,
    };
  } catch {
    return null;
  }
}

/**
 * Hook for managing video transcripts
 * @param options - Hook options
 * @returns Video management functions and state
 */
export function useVideos(options: UseVideosOptions = {}): UseVideosReturn {
  const { defaultOptions = {} } = options;
  const mergedDefaults = { ...DEFAULT_VIDEO_OPTIONS, ...defaultOptions };
  
  const [videos, setVideos] = useState<IProcessedVideo[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState<IVideoProcessingProgress | null>(null);
  const [error, setError] = useState<string | null>(null);

  /**
   * Update progress state
   */
  const updateProgress = useCallback((
    videoUrl: string,
    status: IVideoProcessingProgress['status'],
    progressPercent: number,
    message: string
  ) => {
    setProgress({
      videoUrl,
      status,
      progress: progressPercent,
      message,
    });
  }, []);

  /**
   * Process a video URL
   */
  const processVideo = useCallback(async (
    url: string,
    processingOptions?: Partial<IVideoProcessingOptions>
  ): Promise<IProcessedVideo | null> => {
    const opts = { ...mergedDefaults, ...processingOptions };
    
    setIsProcessing(true);
    setError(null);
    
    try {
      const parsed = parseVideoUrl(url);
      if (!parsed) {
        throw new Error('Unsupported video URL. Supported platforms: YouTube, Vimeo, Loom, Dailymotion, Twitch');
      }
      
      const { platform, videoId } = parsed;
      
      updateProgress(url, 'fetching_metadata', 10, 'Fetching video metadata...');
      
      const metadata = await fetchVideoMetadata(platform, videoId, url);
      
      updateProgress(url, 'fetching_transcript', 30, 'Fetching transcript...');
      
      let transcript: IVideoTranscript | null = null;
      
      if (platform === 'youtube') {
        transcript = await fetchYouTubeTranscript(videoId);
      }
      
      if (!transcript && opts.useAudioFallback) {
        updateProgress(url, 'transcribing', 50, 'Transcript not available. Audio transcription would be used in production.');
        transcript = {
          fullText: `[Video: ${metadata.title}]\n\nTranscript not available. In production, audio would be extracted and transcribed using Whisper API.\n\nVideo URL: ${url}`,
          segments: [],
          language: opts.preferredLanguage,
          isAutoGenerated: true,
        };
      }
      
      const video: IProcessedVideo = {
        id: generateId(),
        metadata,
        transcript,
        isVectorized: false,
        vectorEntryIds: [],
        status: 'complete',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      
      if (opts.autoVectorize && transcript) {
        updateProgress(url, 'vectorizing', 70, 'Vectorizing transcript...');
        
        const content = buildVideoContent(video);
        
        const embeddingResult = await window.vectorStoreAPI?.generateEmbedding(content);
        if (embeddingResult?.embedding) {
          const entry = await window.vectorStoreAPI?.addEntry({
            sourceType: 'video',
            content,
            embedding: embeddingResult.embedding,
            metadata: {
              title: metadata.title,
              sourcePath: url,
              platform: metadata.platform,
              videoId: metadata.videoId,
              author: metadata.author,
              duration: metadata.duration,
              tags: metadata.tags,
            },
          });
          
          if (entry) {
            video.isVectorized = true;
            video.vectorEntryIds = [entry.id];
          }
        }
      }
      
      updateProgress(url, 'complete', 100, 'Video processed successfully');
      
      setVideos(prev => [...prev, video]);
      setIsProcessing(false);
      setProgress(null);
      
      return video;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to process video';
      setError(message);
      setIsProcessing(false);
      setProgress(null);
      return null;
    }
  }, [mergedDefaults, updateProgress]);

  /**
   * Vectorize a video
   */
  const vectorizeVideo = useCallback(async (videoId: string): Promise<void> => {
    const video = videos.find(v => v.id === videoId);
    if (!video) {
      setError('Video not found');
      return;
    }
    
    if (video.isVectorized) {
      return;
    }
    
    if (!video.transcript) {
      setError('No transcript available to vectorize');
      return;
    }
    
    try {
      const content = buildVideoContent(video);
      
      const embeddingResult = await window.vectorStoreAPI?.generateEmbedding(content);
      if (!embeddingResult?.embedding) {
        throw new Error('Failed to generate embedding');
      }
      
      const entry = await window.vectorStoreAPI?.addEntry({
        sourceType: 'video',
        content,
        embedding: embeddingResult.embedding,
        metadata: {
          title: video.metadata.title,
          sourcePath: video.metadata.videoUrl,
          platform: video.metadata.platform,
          videoId: video.metadata.videoId,
          author: video.metadata.author,
          duration: video.metadata.duration,
          tags: video.metadata.tags,
        },
      });
      
      if (!entry) {
        throw new Error('Failed to add entry to vector store');
      }
      
      setVideos(prev => prev.map(v => 
        v.id === videoId
          ? {
              ...v,
              isVectorized: true,
              vectorEntryIds: [...v.vectorEntryIds, entry.id],
              updatedAt: new Date(),
            }
          : v
      ));
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to vectorize video';
      setError(message);
    }
  }, [videos]);

  /**
   * Delete a video
   */
  const deleteVideo = useCallback(async (videoId: string): Promise<void> => {
    const video = videos.find(v => v.id === videoId);
    if (!video) return;
    
    try {
      for (const entryId of video.vectorEntryIds) {
        await window.vectorStoreAPI?.deleteEntry(entryId);
      }
      
      setVideos(prev => prev.filter(v => v.id !== videoId));
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete video';
      setError(message);
    }
  }, [videos]);

  /**
   * Clear error
   */
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    videos,
    isProcessing,
    progress,
    error,
    processVideo,
    vectorizeVideo,
    deleteVideo,
    clearError,
  };
}

/**
 * Build content string for vectorization
 */
function buildVideoContent(video: IProcessedVideo): string {
  const parts: string[] = [];
  
  parts.push(`# ${video.metadata.title}`);
  parts.push('');
  parts.push(`**Platform:** ${video.metadata.platform}`);
  parts.push(`**Author:** ${video.metadata.author}`);
  if (video.metadata.duration > 0) {
    const minutes = Math.floor(video.metadata.duration / 60);
    const seconds = video.metadata.duration % 60;
    parts.push(`**Duration:** ${minutes}:${seconds.toString().padStart(2, '0')}`);
  }
  parts.push(`**URL:** ${video.metadata.videoUrl}`);
  parts.push('');
  
  if (video.metadata.description) {
    parts.push('## Description');
    parts.push(video.metadata.description);
    parts.push('');
  }
  
  if (video.metadata.tags.length > 0) {
    parts.push(`**Tags:** ${video.metadata.tags.join(', ')}`);
    parts.push('');
  }
  
  if (video.transcript) {
    parts.push('## Transcript');
    parts.push(video.transcript.fullText);
  }
  
  return parts.join('\n');
}
